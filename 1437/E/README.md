## E. Make It Increasing

https://codeforces.com/contest/1437/problem/E

### 心路历程
从一开始的觉得这个问题可以拆成N个子问题，分区段进行。再觉得这跟dp问题很像，和胡交流后知道了这类问题叫LIS，到去做力扣的最长上升子序列。

到把最长上升子序列运用到这道题中发现思路很混乱。再在某天夜里乱想的时候想到可以减去位置信息，这样问题就转换成了最长非严格上升子序列（不下降）。

把LIS中学到的贪心+二分查找运用过来，发现在贪心过程中，二分查找没找到最佳位置（后面还需要再去了解一下为什么会这样？），再使用c++std中的upper_bound函数，找到了最佳的位置。

再在提交过程中，发现还是有错误，并且自己很难解决。于是看了[排行榜](https://codeforces.com/contest/1437/standings)中排名第一的大神的题解，看到了自己是没有在单次循环中加入判断当前数是否合适这一步骤。

但是在看大神的提交中，发现自己跟神的思路一致，这说明我的思路还是能到位的。

但是，在空间上，完败。因为大神是用多少d开辟多少d，而我是直接开辟了最大的情况。当然，在当前阶段，还是可以不太考虑这个问题的。

### 总结
1. 最长严格上升子序列和最长不下降子序列不是一个东西
2. 在有严格排序信息时，减去位置信息，这样就可以忽略严格上升这一苛刻的条件了。